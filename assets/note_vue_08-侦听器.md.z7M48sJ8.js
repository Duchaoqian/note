import{_ as i,c as a,o as n,ag as l}from"./chunks/framework.CgAj5nG9.js";const o=JSON.parse('{"title":"侦听器","description":"","frontmatter":{},"headers":[],"relativePath":"note/vue/08-侦听器.md","filePath":"note/vue/08-侦听器.md","lastUpdated":1751877942000}'),e={name:"note/vue/08-侦听器.md"};function t(p,s,h,k,B,d){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="侦听器" tabindex="-1">侦听器 <a class="header-anchor" href="#侦听器" aria-label="Permalink to &quot;侦听器&quot;">​</a></h1><ol><li>区别 <ol><li>计算属性 <ol><li>主要是通过原始数据 生成一个新的属性</li><li>计算属性是通过已有的属性计算得到一个新的属性</li><li>当计算属性中用到的所有数据 只要有一个发生改变 函数就会重新执行</li><li>计算属性初始化完会立即执行</li></ol></li><li>侦听器 <ol><li>是不会创建一个新的属性</li><li>监听这个数据的变化 做一些其他的事情 (例如网络请求)</li><li>侦听器 只有当前数据发生改变时才会重新执行</li><li>侦听器 只有在数据发生改变时才会执行</li></ol></li></ol></li><li>immediate <ol><li>immediate 用来指定 初始化完成是否需要立即执行 handler 方法</li></ol></li><li>监听使用方法<div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes min-dark min-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6B737C;--shiki-dark:#6B737C;">   // watch 里面</span></span>
<span class="line"><span style="--shiki-light:#6B737C;--shiki-dark:#6B737C;">   // 方法名称需要写成字符串的形式</span></span>
<span class="line"><span style="--shiki-light:#6B737C;--shiki-dark:#6B737C;">   // 前提是方法需要在 methods 中声明一下</span></span>
<span class="line"><span style="--shiki-light:#6B737C;--shiki-dark:#6B737C;">   //   &#39;user.lastname&#39;: [&#39;handler1&#39;, &#39;handler2&#39;, &#39;handler3&#39;],</span></span>
<span class="line"><span style="--shiki-light:#FFAB70;--shiki-dark:#FFAB70;">   &#39;user.lastname&#39;</span><span style="--shiki-light:#B392F0;--shiki-dark:#B392F0;">: [</span></span>
<span class="line"><span style="--shiki-light:#FFAB70;--shiki-dark:#FFAB70;">      &#39;handler1&#39;</span><span style="--shiki-light:#BBBBBB;--shiki-dark:#BBBBBB;">,</span><span style="--shiki-light:#6B737C;--shiki-dark:#6B737C;"> // 需要使用在methods中定义的方法是 可以使用这种形式</span></span>
<span class="line"><span style="--shiki-light:#B392F0;--shiki-dark:#B392F0;">      {</span></span>
<span class="line"><span style="--shiki-light:#B392F0;--shiki-dark:#B392F0;">         handler() {</span></span>
<span class="line"><span style="--shiki-light:#79B8FF;--shiki-dark:#79B8FF;">            console</span><span style="--shiki-light:#B392F0;--shiki-dark:#B392F0;">.log(</span><span style="--shiki-light:#FFAB70;--shiki-dark:#FFAB70;">&#39;2&#39;</span><span style="--shiki-light:#B392F0;--shiki-dark:#B392F0;">)</span></span>
<span class="line"><span style="--shiki-light:#B392F0;--shiki-dark:#B392F0;">         }</span></span>
<span class="line"><span style="--shiki-light:#B392F0;--shiki-dark:#B392F0;">      }</span><span style="--shiki-light:#BBBBBB;--shiki-dark:#BBBBBB;">,</span><span style="--shiki-light:#6B737C;--shiki-dark:#6B737C;"> // 在数组中使用配置对象的形式</span></span>
<span class="line"><span style="--shiki-light:#F97583;--shiki-dark:#F97583;">      function</span><span style="--shiki-light:#B392F0;--shiki-dark:#B392F0;"> () {</span></span>
<span class="line"><span style="--shiki-light:#79B8FF;--shiki-dark:#79B8FF;">         console</span><span style="--shiki-light:#B392F0;--shiki-dark:#B392F0;">.log(</span><span style="--shiki-light:#FFAB70;--shiki-dark:#FFAB70;">&#39;3&#39;</span><span style="--shiki-light:#B392F0;--shiki-dark:#B392F0;">)</span></span>
<span class="line"><span style="--shiki-light:#B392F0;--shiki-dark:#B392F0;">      } </span><span style="--shiki-light:#6B737C;--shiki-dark:#6B737C;">// 在数组中使用函数的形式</span></span>
<span class="line"><span style="--shiki-light:#B392F0;--shiki-dark:#B392F0;">   ]</span></span></code></pre></div></li></ol>`,2)]))}const F=i(e,[["render",t]]);export{o as __pageData,F as default};
